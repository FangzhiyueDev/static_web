<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>

        // function getCallback(name, age, callback) {
        //     var u = {};
        //     u.name = name;
        //     u.age = age;
        //     callback(u);
        //
        // }
        //
        // getCallback("fang", 12, new function (user) {
        //     var u = user;
        //     alert(u.name)
        //     alert(u.age)
        // });


        //typeScript

        //   var p=new Person();
        // for(var de in p){
        //     document.write(de+"<br/>");
        // }
        //
        // var perso=Person.call(p);
        //
        // alert(perso.name)
        //
        // alert(Person.call(p));
        //
        // alert(this)
        //
        //  var nump=Number.call(p);
        //
        //
        //   alert(typeof nump)


        // alert(window.Person);


        function Person() {
            this.address = "sdgs";
            this.age = "age";
            return this;
        }

        /**
         * 虽然在Person里面添加了address属性了age属性，但是没有调用，这时window.address和window.age是undefined
         */
        //  alert(window.address)//undefined
        // alert(window.age)//undefined


        function demo1() {
            var address = "sdafsaf";
            return function () {
                // this.address="sfgds"
                return function () {
                    alert(window.address);
                }
            }();
        }


        /**
         * 对于上面的闭包，我们先是在demo1函数里面定义了一个name变量，在内部函数中返回了一个
         * 一个函数，在最内层的函数中输出window.name的值，打印的结果是“sfgds”
         * 下面我们根据我们的实践给出实践结果
         *          1.对于一个函数，如果我们在内部直接写一个局部变量(这个局部变量不能使用var申明)，在没有调用的时候，局部变量不会被加入到全局window中当做属性
         *              当我们调用的时候，这时局部变量会被加入到window中变为属性(前提是没有使用var申明)
         */
        function demo3() {
            age = 12;
        }

        //alert(window.age)//undefined。尽管age在的demo3里面定义了，但是没有调用，所以没有添加到window对象中
        demo4();//在这里执行，所以之后执行的代码window里面被添加了age属性
        //  alert(window.age);//12.输出的是window的age属性

        function demo4() {
            age = 12;//向window里面添加了age属性，所以调用后 alert(age)==12，  alert(window.age)==12；
        }

        // alert(window.age);//12


        /**
         *          2.对于一个函数，如果内部使用了this，直接调用函数。那么this上面添加的属性都会被添加到全局window中变为属性，具体请看Person的构造
         *          3.我们一般定义的变量，都会被加入到window对象中，成为属性，我们一般直接使用变量名直接使用，同样我们也可以通过window.的形式
         *              去访问，这时如果变量真的没有定义，但是不会报错，只会报undefined。
         *          4.默认this指向window，不管是构造函数还是普通函数都是这样。如果是构造函数，如果我们通过new操作符，那么这个this将指向构造函数对应的
         *              对象，如果不这样，那么依旧指向window。当然我们可以使用函数的默认的方法call(),apply()方法来改变this的指向。例如下面的
         *              var perso=Person.call(this);,对Person函数内部的this指向window对象
         *          5.在函数内部，如果不使用var定义的变量，调用后会被添加到window的对象中
         *
         */


        //demo1()();//undefined。原因是内部我们定义了局部的address，但是没有添加到window里面，所以打印为undefiend


        function demo5() {
            var array = new Array();
            for (var i = 0; i < 10; i++) {
                array[i] = function () {
                    alert(window.i);
                }
            }

        }

        //demo5();

        // alert(array);//这个由于没有定义，没有使用window.array的形式。这时程序会直接中止掉，与window.array不同，window.array只会报错
        //但不会中止掉

        // for(var i=0;i<10;i++){
        //     window.array[i]();//undefiend
        // }

        /**
         * 函数表达式内部不能访问到存放当前函数的变量
         * 或者说对象构建函数或使用对象字面量的形式定义的对象内部的函数不能够直接访问
         * 对象的其他属性和方法，同样的也就不能访问内部函数的函数变量
         */

        /**
         * 下面测试this
         */
        function fun(n, o) {
            alert(o);
            return obj = {
                address: "fang",
                fun: function (m) {
                    //alert(address);//undefined
                    alert(window.address);//undefined
                    alert(window.obj)//可以，原因是前面返回了一个obj，但是没有使用var申明，默认加入到window对象中
                    return fun(m, n)//这里fun对应的是外部的fun函数，而不是对象内部的fun，
                    //return obj.fun(m,n);//这里调用的是内部的fun函数，这会进行递归调用
                }
            }
        }

        var a = fun(0);
        a.fun(1)


    </script>
</head>
<body>

<script>

    var demo;
    // for(demo in Number){
    //     document.write(demo)
    // }

    inner = "<div class=\"commentSingle\">\n" +
        "    <img src=\"../images/head.jpeg\" align=\"top\" class=\"commentListUserHead\">\n" +
        "    <div class=\"allComment\">\n" +
        "        <div class=\"dimension\"></div>\n" +
        "        <h5><span class=\"currentSelect \">帅帅的小伙子</span></h5>\n" +
        "        <p class=\"commentContent\">这么帅气的视频，我一定要好好看完这些东西</p>\n" +
        "        <span class=\"commentDate\">2018年11月14日</span>\n" +
        "    </div>\n" +
        "</div>\n";



</script>

<div class="commentSingle">
    <img src="../images/head.jpeg" align="top" class="commentListUserHead">
    <div class="allComment">
        <div class="dimension"></div>
        <h5><span class="currentSelect ">帅帅的小伙子</span></h5>
        <p class="commentContent">这么帅气的视频，我一定要好好看完这些东西</p>
        <span class="commentDate">2018年11月14日</span>
    </div>
</div>

</body>
</html>